"""
Geocoding service using OpenStreetMap Nominatim API.
Generated By: Cursor (Claude Sonnet 4)
"""

from __future__ import annotations

import asyncio
import time
from typing import Any

import httpx
from typing_extensions import Self

from .models import GeocodeRequest, GeocodeResponse, GeocodeResult

# Constants for coordinate validation
MIN_LATITUDE = -90.0
MAX_LATITUDE = 90.0
MIN_LONGITUDE = -180.0
MAX_LONGITUDE = 180.0


def _parse_geocode_item(item: dict[str, Any]) -> GeocodeResult | None:
    """Parse a single geocoding result item, returning None if invalid."""
    try:
        return GeocodeResult(
            display_name=item.get("display_name", ""),
            latitude=float(item.get("lat", 0.0)),
            longitude=float(item.get("lon", 0.0)),
            importance=item.get("importance"),
            place_type=item.get("type"),
            place_class=item.get("class"),
            osm_id=item.get("osm_id"),
            osm_type=item.get("osm_type"),
        )
    except (ValueError, TypeError):
        # Skip malformed results
        return None


class RateLimiter:
    """Rate limiter that enforces 1 request per second for Nominatim usage policy."""

    def __init__(self, requests_per_second: float = 1.0) -> None:
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0.0

    async def wait_if_needed(self) -> None:
        """Wait if necessary to respect rate limits."""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time

        if time_since_last < self.min_interval:
            wait_time = self.min_interval - time_since_last
            await asyncio.sleep(wait_time)

        self.last_request_time = time.time()


class NominatimGeocodingService:
    """Service for geocoding addresses using OpenStreetMap Nominatim API."""

    def __init__(
        self,
        base_url: str = "https://nominatim.openstreetmap.org",
        user_agent: str = "mcp-location-server/0.1.0",
        timeout: float = 10.0,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.user_agent = user_agent
        self.timeout = timeout
        self.rate_limiter = RateLimiter(requests_per_second=1.0)

        # Create HTTP client with proper headers
        self.client = httpx.AsyncClient(
            headers={
                "User-Agent": self.user_agent,
                "Accept": "application/json",
                "Accept-Language": "en-US,en;q=0.9",
            },
            timeout=self.timeout,
        )

    async def __aenter__(self) -> Self:
        """Async context manager entry."""
        return self

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: types.TracebackType | None,
    ) -> None:
        """Async context manager exit."""
        await self.client.aclose()

    async def geocode(self, request: GeocodeRequest) -> GeocodeResponse:
        """
        Geocode an address or location name to coordinates.

        Args:
            request: GeocodeRequest containing query and limit

        Returns:
            GeocodeResponse with results

        Raises:
            httpx.HTTPError: If the API request fails
            ValidationError: If the response cannot be parsed
        """
        # Respect rate limits
        await self.rate_limiter.wait_if_needed()

        # Build the API URL
        url = f"{self.base_url}/search"

        params = {
            "q": request.query,  # httpx will handle URL encoding in params
            "format": "json",
            "addressdetails": "1",
            "limit": str(request.limit),
            "dedupe": "1",  # Remove duplicate results
            "extratags": "1",  # Include extra tags
        }

        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()

            # Parse the JSON response
            data = response.json()

            # Convert to our model format
            results = []
            for item in data:
                result = _parse_geocode_item(item)
                if result is not None:
                    results.append(result)

            return GeocodeResponse(
                results=results,
                query=request.query,
                count=len(results),
            )

        except httpx.HTTPError as e:
            # Re-raise with more context
            msg = f"Failed to geocode '{request.query}': {e!s}"
            raise httpx.HTTPError(msg) from e
        except (ValueError, KeyError) as e:
            # Handle JSON parsing errors
            msg = f"Invalid response format from Nominatim API: {e!s}"
            raise ValueError(msg) from e

    async def reverse_geocode(
        self,
        latitude: float,
        longitude: float,
    ) -> GeocodeResult | None:
        """
        Reverse geocode coordinates to an address.

        Args:
            latitude: Latitude in decimal degrees (-90 to 90)
            longitude: Longitude in decimal degrees (-180 to 180)

        Returns:
            GeocodeResult if found, None otherwise

        Raises:
            ValueError: If coordinates are invalid
            httpx.HTTPError: If the API request fails
        """
        # Validate coordinates
        try:
            lat = float(latitude)
            lon = float(longitude)
        except (TypeError, ValueError) as e:
            msg = f"Invalid coordinate values: lat={latitude}, lon={longitude}"
            raise ValueError(msg) from e

        if not (MIN_LATITUDE <= lat <= MAX_LATITUDE):
            msg = (
                f"Latitude must be between {MIN_LATITUDE} and {MAX_LATITUDE}, got {lat}"
            )
            raise ValueError(msg)

        if not (MIN_LONGITUDE <= lon <= MAX_LONGITUDE):
            msg = f"Longitude must be between {MIN_LONGITUDE} and {MAX_LONGITUDE}, got {lon}"
            raise ValueError(msg)

        # Respect rate limits
        await self.rate_limiter.wait_if_needed()

        url = f"{self.base_url}/reverse"
        params = {
            "lat": str(lat),
            "lon": str(lon),
            "format": "json",
            "addressdetails": "1",
            "extratags": "1",
        }

        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()

            data = response.json()

            # Check if we got a valid result
            if not data or "error" in data:
                return None

            return GeocodeResult(
                display_name=data.get("display_name", ""),
                latitude=float(data.get("lat", latitude)),
                longitude=float(data.get("lon", longitude)),
                importance=data.get("importance"),
                place_type=data.get("type"),
                place_class=data.get("class"),
                osm_id=data.get("osm_id"),
                osm_type=data.get("osm_type"),
            )

        except httpx.HTTPError as e:
            msg = f"Failed to reverse geocode ({latitude}, {longitude}): {e!s}"
            raise httpx.HTTPError(msg) from e
        except (ValueError, KeyError, TypeError):
            # Return None for parsing errors in reverse geocoding
            return None


# Global service instance
_geocoding_service: NominatimGeocodingService | None = None


async def get_geocoding_service() -> NominatimGeocodingService:
    """Get or create the global geocoding service instance."""
    global _geocoding_service

    if _geocoding_service is None:
        _geocoding_service = NominatimGeocodingService()

    return _geocoding_service


async def close_geocoding_service() -> None:
    """Close the global geocoding service instance."""
    global _geocoding_service

    if _geocoding_service is not None:
        await _geocoding_service.client.aclose()
        _geocoding_service = None
