"""
Elevation service using Open Topo Data API.
Generated By: Cursor (Claude Sonnet 4)
"""

import asyncio
import time
from typing import Optional

import httpx
from pydantic import ValidationError

from .models import ElevationRequest, ElevationResponse, ElevationResult, ElevationData


class ElevationRateLimiter:
    """Rate limiter for Open Topo Data API (1 call per second)."""
    
    def __init__(self, requests_per_second: float = 1.0) -> None:
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0.0
    
    async def wait_if_needed(self) -> None:
        """Wait if necessary to respect rate limits."""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.min_interval:
            wait_time = self.min_interval - time_since_last
            await asyncio.sleep(wait_time)
        
        self.last_request_time = time.time()


class OpenTopoDataElevationService:
    """Service for getting elevation data using Open Topo Data API."""
    
    def __init__(
        self, 
        base_url: str = "https://api.opentopodata.org",
        user_agent: str = "mcp-location-server/0.1.0",
        timeout: float = 10.0
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.user_agent = user_agent
        self.timeout = timeout
        self.rate_limiter = ElevationRateLimiter(requests_per_second=1.0)
        
        # Create HTTP client with proper headers
        self.client = httpx.AsyncClient(
            headers={
                "User-Agent": self.user_agent,
                "Accept": "application/json",
            },
            timeout=self.timeout,
        )
    
    async def __aenter__(self) -> "OpenTopoDataElevationService":
        """Async context manager entry."""
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Async context manager exit."""
        await self.client.aclose()
    
    def _meters_to_feet(self, meters: float) -> float:
        """Convert meters to feet."""
        return meters * 3.28084
    
    async def get_elevation(self, request: ElevationRequest) -> ElevationResponse:
        """
        Get elevation data for coordinates.
        
        Args:
            request: ElevationRequest containing latitude, longitude, and dataset
            
        Returns:
            ElevationResponse with elevation data in meters and feet
            
        Raises:
            httpx.HTTPError: If the API request fails
            ValidationError: If the response cannot be parsed
        """
        # Respect rate limits
        await self.rate_limiter.wait_if_needed()
        
        # Build the API URL
        url = f"{self.base_url}/v1/{request.dataset}"
        
        params = {
            "locations": f"{request.latitude},{request.longitude}",
            "format": "json",
        }
        
        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()
            
            # Parse the JSON response
            data = response.json()
            
            # Check for API errors
            if data.get("status") != "OK":
                error_msg = data.get("error", "Unknown error from elevation API")
                raise ValueError(f"Elevation API error: {error_msg}")
            
            # Extract elevation data
            results = []
            api_results = data.get("results", [])
            
            if api_results:
                api_result = api_results[0]  # We only sent one location
                elevation_meters = api_result.get("elevation")
                dataset_name = api_result.get("dataset")
                
                if elevation_meters is not None:
                    elevation_feet = self._meters_to_feet(elevation_meters)
                    
                    elevation_data = ElevationData(
                        meters=elevation_meters,
                        feet=elevation_feet,
                        dataset=dataset_name
                    )
                    
                    result = ElevationResult(
                        latitude=request.latitude,
                        longitude=request.longitude,
                        elevation=elevation_data
                    )
                    
                    results.append(result)
            
            return ElevationResponse(
                results=results,
                count=len(results)
            )
            
        except httpx.HTTPError as e:
            # Re-raise with more context
            raise httpx.HTTPError(
                f"Failed to get elevation for ({request.latitude}, {request.longitude}): {str(e)}"
            ) from e
        except (ValueError, KeyError) as e:
            # Handle JSON parsing errors
            raise ValueError(
                f"Invalid response format from elevation API: {str(e)}"
            ) from e
    
    async def get_elevation_simple(
        self, 
        latitude: float, 
        longitude: float,
        dataset: str = "srtm90m"
    ) -> Optional[ElevationData]:
        """
        Simple elevation lookup for a single coordinate.
        
        Args:
            latitude: Latitude in decimal degrees
            longitude: Longitude in decimal degrees
            dataset: Dataset to use (default: srtm90m)
            
        Returns:
            ElevationData if found, None if not available
        """
        try:
            request = ElevationRequest(
                latitude=latitude,
                longitude=longitude,
                dataset=dataset
            )
            response = await self.get_elevation(request)
            
            if response.results:
                return response.results[0].elevation
            
            return None
            
        except (httpx.HTTPError, ValidationError):
            # Return None for any errors in simple mode
            return None


# Global service instance
_elevation_service: Optional[OpenTopoDataElevationService] = None


async def get_elevation_service() -> OpenTopoDataElevationService:
    """Get or create the global elevation service instance."""
    global _elevation_service
    
    if _elevation_service is None:
        _elevation_service = OpenTopoDataElevationService()
    
    return _elevation_service


async def close_elevation_service() -> None:
    """Close the global elevation service instance."""
    global _elevation_service
    
    if _elevation_service is not None:
        await _elevation_service.client.aclose()
        _elevation_service = None