"""
MCP Location Server implementation.
Generated By: Cursor (Claude Sonnet 4)
"""

import asyncio
import logging
from typing import Any, Dict

from mcp.server.fastmcp import FastMCP
from mcp.types import ToolAnnotations
from pydantic import ValidationError
import httpx

from .models import GeocodeRequest, GeocodeResponse
from .geocoding import get_geocoding_service, close_geocoding_service


class LocationServer:
    """Location MCP Server for geocoding addresses to coordinates."""
    
    def __init__(self) -> None:
        self.logger = logging.getLogger("mcp_location_server.LocationServer")
        self.logger.info("Initializing Location MCP Server")
    
    async def geocode_address(
        self, 
        query: str, 
        limit: int = 1
    ) -> Dict[str, Any]:
        """
        Geocode an address or location name to latitude/longitude coordinates.
        
        Args:
            query: The address or location to geocode (e.g., "1600 Pennsylvania Avenue, Washington DC")
            limit: Maximum number of results to return (1-10, default: 1)
            
        Returns:
            Dictionary containing geocoding results
        """
        self.logger.info(f"Geocoding request: query='{query}', limit={limit}")
        
        try:
            # Validate the request
            request = GeocodeRequest(query=query, limit=limit)
            
            # Get the geocoding service
            service = await get_geocoding_service()
            
            # Perform geocoding
            response = await service.geocode(request)
            
            self.logger.info(f"Geocoding successful: found {response.count} results")
            
            # Convert to dictionary for MCP response
            return {
                "results": [
                    {
                        "display_name": result.display_name,
                        "latitude": result.latitude,
                        "longitude": result.longitude,
                        "importance": result.importance,
                        "type": result.place_type,
                        "class": result.place_class,
                        "osm_id": result.osm_id,
                        "osm_type": result.osm_type,
                    }
                    for result in response.results
                ],
                "query": response.query,
                "count": response.count,
            }
            
        except ValidationError as e:
            self.logger.error(f"Request validation error: {e}")
            return {
                "error": "Invalid request",
                "message": str(e),
                "results": [],
                "query": query,
                "count": 0,
            }
        except httpx.HTTPError as e:
            self.logger.error(f"HTTP error during geocoding: {e}")
            return {
                "error": "API request failed",
                "message": str(e),
                "results": [],
                "query": query,
                "count": 0,
            }
        except Exception as e:
            self.logger.error(f"Unexpected error during geocoding: {e}")
            return {
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "results": [],
                "query": query,
                "count": 0,
            }
    
    async def reverse_geocode_coordinates(
        self, 
        latitude: float, 
        longitude: float
    ) -> Dict[str, Any]:
        """
        Reverse geocode coordinates to an address.
        
        Args:
            latitude: Latitude in decimal degrees
            longitude: Longitude in decimal degrees
            
        Returns:
            Dictionary containing reverse geocoding result
        """
        self.logger.info(f"Reverse geocoding request: lat={latitude}, lon={longitude}")
        
        try:
            # Get the geocoding service
            service = await get_geocoding_service()
            
            # Perform reverse geocoding
            result = await service.reverse_geocode(latitude, longitude)
            
            if result is None:
                self.logger.info("Reverse geocoding: no result found")
                return {
                    "result": None,
                    "latitude": latitude,
                    "longitude": longitude,
                    "found": False,
                }
            
            self.logger.info("Reverse geocoding successful")
            
            return {
                "result": {
                    "display_name": result.display_name,
                    "latitude": result.latitude,
                    "longitude": result.longitude,
                    "importance": result.importance,
                    "type": result.place_type,
                    "class": result.place_class,
                    "osm_id": result.osm_id,
                    "osm_type": result.osm_type,
                },
                "latitude": latitude,
                "longitude": longitude,
                "found": True,
            }
            
        except ValueError as e:
            self.logger.error(f"Invalid coordinates for reverse geocoding: {e}")
            return {
                "error": "Invalid coordinates",
                "message": str(e),
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except httpx.HTTPError as e:
            self.logger.error(f"HTTP error during reverse geocoding: {e}")
            return {
                "error": "API request failed",
                "message": str(e),
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except Exception as e:
            self.logger.error(f"Unexpected error during reverse geocoding: {e}")
            return {
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }


async def create_server() -> FastMCP:
    """Create and configure the MCP server."""
    logging.basicConfig(level=logging.INFO)
    
    # Create the MCP server
    mcp = FastMCP(
        "location_mcp_server",
        instructions=(
            "You are a location and geocoding assistant. Use the provided tools to help users "
            "find coordinates for addresses and locations, or convert coordinates back to addresses. "
            "You can handle addresses, cities, landmarks, and points of interest."
        ),
    )
    
    # Create the location server instance
    location_server = LocationServer()
    
    # Add the geocoding tool
    mcp.add_tool(
        location_server.geocode_address,
        "geocode",
        title="Geocode address or location to coordinates",
        description=(
            "Convert an address, city name, or landmark to latitude/longitude coordinates. "
            "Supports various formats like '123 Main St, City, State', 'Tokyo, Japan', "
            "or 'Eiffel Tower'. Returns up to the specified number of results."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=True,  # Can search for any location worldwide
        ),
        structured_output=True,
    )
    
    # Add the reverse geocoding tool
    mcp.add_tool(
        location_server.reverse_geocode_coordinates,
        "reverse_geocode",
        title="Reverse geocode coordinates to address",
        description=(
            "Convert latitude/longitude coordinates to a human-readable address. "
            "Provide decimal degree coordinates (e.g., lat=40.7128, lon=-74.0060 for NYC)."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=True,
        ),
        structured_output=True,
    )
    
    return mcp


# Global app instance for the entry point
app: FastMCP = None


async def get_app() -> FastMCP:
    """Get or create the global app instance."""
    global app
    if app is None:
        app = await create_server()
    return app


async def main() -> None:
    """Main entry point for running the server."""
    import sys
    
    try:
        server = await create_server()
        
        # Check if running in STDIO mode (for MCP clients like Cursor)
        # or HTTP mode (for testing/debugging)
        if len(sys.argv) > 1 and sys.argv[1] == "--http":
            logging.info("Starting server in HTTP mode")
            await server.run_streamable_http_async()
        else:
            logging.info("Starting server in STDIO mode for MCP client")
            await server.run_stdio_async()
    except KeyboardInterrupt:
        logging.info("Server stopped by user")
    except Exception as e:
        logging.error(f"Server error: {e}")
        raise
    finally:
        # Clean up the geocoding service
        await close_geocoding_service()


if __name__ == "__main__":
    asyncio.run(main()) 