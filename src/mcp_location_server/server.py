"""
MCP Location Server implementation.
Generated By: Cursor (Claude Sonnet 4)
"""

from __future__ import annotations

import asyncio
import logging
import sys
from typing import Any

import httpx
from mcp.server.fastmcp import FastMCP
from mcp.types import ToolAnnotations
from pydantic import ValidationError

from .elevation import close_elevation_service, get_elevation_service
from .geocoding import close_geocoding_service, get_geocoding_service
from .models import ElevationRequest, GeocodeRequest


class LocationServer:
    """Location MCP Server for geocoding addresses to coordinates."""

    def __init__(self) -> None:
        self.logger = logging.getLogger("mcp_location_server.LocationServer")
        self.logger.info("Initializing Location MCP Server")

    async def geocode_address(
        self,
        query: str,
        limit: int = 1,
    ) -> dict[str, Any]:
        """
        Geocode an address or location name to latitude/longitude coordinates.

        Args:
            query: The address or location to geocode (e.g., "1600 Pennsylvania Avenue, Washington DC")
            limit: Maximum number of results to return (1-10, default: 1)

        Returns:
            Dictionary containing geocoding results
        """
        self.logger.info("Geocoding request: query='%s', limit=%d", query, limit)

        try:
            # Validate the request
            request = GeocodeRequest(query=query, limit=limit)

            # Get the geocoding service
            service = await get_geocoding_service()

            # Perform geocoding
            response = await service.geocode(request)

            self.logger.info("Geocoding successful: found %d results", response.count)

            # Convert to dictionary for MCP response
            return {
                "results": [
                    {
                        "display_name": result.display_name,
                        "latitude": result.latitude,
                        "longitude": result.longitude,
                        "importance": result.importance,
                        "type": result.place_type,
                        "class": result.place_class,
                        "osm_id": result.osm_id,
                        "osm_type": result.osm_type,
                    }
                    for result in response.results
                ],
                "query": response.query,
                "count": response.count,
            }

        except ValidationError:
            self.logger.exception("Request validation error")
            return {
                "error": "Invalid request",
                "message": "Invalid request parameters",
                "results": [],
                "query": query,
                "count": 0,
            }
        except httpx.HTTPError:
            self.logger.exception("HTTP error during geocoding")
            return {
                "error": "API request failed",
                "message": "Failed to connect to geocoding service",
                "results": [],
                "query": query,
                "count": 0,
            }
        except Exception:
            self.logger.exception("Unexpected error during geocoding")
            return {
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "results": [],
                "query": query,
                "count": 0,
            }

    async def reverse_geocode_coordinates(
        self,
        latitude: float,
        longitude: float,
    ) -> dict[str, Any]:
        """
        Reverse geocode coordinates to an address.

        Args:
            latitude: Latitude in decimal degrees
            longitude: Longitude in decimal degrees

        Returns:
            Dictionary containing reverse geocoding result
        """
        self.logger.info("Reverse geocoding request: lat=%f, lon=%f", latitude, longitude)

        try:
            # Get the geocoding service
            service = await get_geocoding_service()

            # Perform reverse geocoding
            result = await service.reverse_geocode(latitude, longitude)

            if result is None:
                self.logger.info("Reverse geocoding: no result found")
                return {
                    "result": None,
                    "latitude": latitude,
                    "longitude": longitude,
                    "found": False,
                }
            self.logger.info("Reverse geocoding successful")
            return {
                "result": {
                    "display_name": result.display_name,
                    "latitude": result.latitude,
                    "longitude": result.longitude,
                    "importance": result.importance,
                    "type": result.place_type,
                    "class": result.place_class,
                    "osm_id": result.osm_id,
                    "osm_type": result.osm_type,
                },
                "latitude": latitude,
                "longitude": longitude,
                "found": True,
            }

        except ValueError:
            self.logger.exception("Invalid coordinates for reverse geocoding")
            return {
                "error": "Invalid coordinates",
                "message": "Coordinates are out of valid range",
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except httpx.HTTPError:
            self.logger.exception("HTTP error during reverse geocoding")
            return {
                "error": "API request failed",
                "message": "Failed to connect to geocoding service",
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except Exception:
            self.logger.exception("Unexpected error during reverse geocoding")
            return {
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "result": None,
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }

    async def get_elevation(
        self,
        latitude: float,
        longitude: float,
        dataset: str = "srtm90m",
    ) -> dict[str, Any]:
        """
        Get elevation data for coordinates.

        Args:
            latitude: Latitude in decimal degrees (-90 to 90)
            longitude: Longitude in decimal degrees (-180 to 180)
            dataset: Elevation dataset to use (default: srtm90m)

        Returns:
            Dictionary containing elevation data in meters and feet
        """
        self.logger.info("Elevation request: lat=%f, lon=%f, dataset=%s", latitude, longitude, dataset)

        try:
            # Validate the request
            request = ElevationRequest(
                latitude=latitude,
                longitude=longitude,
                dataset=dataset,
            )

            # Get the elevation service
            service = await get_elevation_service()

            # Get elevation data
            response = await service.get_elevation(request)

            if response.results:
                result = response.results[0]
                self.logger.info("Elevation successful: %fm", result.elevation.meters)

                return {
                    "latitude": result.latitude,
                    "longitude": result.longitude,
                    "elevation_meters": result.elevation.meters,
                    "elevation_feet": result.elevation.feet,
                    "dataset": result.elevation.dataset,
                    "found": True,
                }
            self.logger.info("Elevation: no data available for coordinates")
            return {
                "latitude": latitude,
                "longitude": longitude,
                "elevation_meters": None,
                "elevation_feet": None,
                "dataset": dataset,
                "found": False,
                "message": "No elevation data available for these coordinates",
            }

        except ValidationError:
            self.logger.exception("Request validation error")
            return {
                "error": "Invalid request",
                "message": "Invalid request parameters",
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except httpx.HTTPError:
            self.logger.exception("HTTP error during elevation lookup")
            return {
                "error": "API request failed",
                "message": "Failed to connect to elevation service",
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }
        except Exception:
            self.logger.exception("Unexpected error during elevation lookup")
            return {
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "latitude": latitude,
                "longitude": longitude,
                "found": False,
            }


async def create_server() -> FastMCP:
    """Create and configure the MCP server."""
    logging.basicConfig(level=logging.INFO)

    # Create the MCP server
    mcp = FastMCP(
        "location_mcp_server",
        instructions=(
            "You are a location and geocoding assistant with elevation lookup capabilities. "
            "Available tools: (1) geocode - convert addresses/places to coordinates, "
            "(2) reverse_geocode - convert coordinates to addresses, "
            "(3) get_elevation - get elevation data for coordinates. "
            "Common workflows: address → geocode → coordinates → get_elevation, "
            "or coordinates → reverse_geocode → address. "
            "You can handle addresses, cities, landmarks, and points of interest worldwide."
        ),
    )

    # Create the location server instance
    location_server = LocationServer()

    # Add the geocoding tool
    mcp.add_tool(
        location_server.geocode_address,
        "geocode",
        title="Geocode address or location to coordinates",
        description=(
            "Convert an address, city name, or landmark to latitude/longitude coordinates. "
            "Supports various formats like '123 Main St, City, State', 'Tokyo, Japan', "
            "or 'Eiffel Tower'. Returns up to the specified number of results. "
            "Use these coordinates with get_elevation to find elevation data, or use "
            "reverse_geocode to convert coordinates back to addresses."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=True,  # Can search for any location worldwide
        ),
        structured_output=True,
    )

    # Add the reverse geocoding tool
    mcp.add_tool(
        location_server.reverse_geocode_coordinates,
        "reverse_geocode",
        title="Reverse geocode coordinates to address",
        description=(
            "Convert latitude/longitude coordinates to a human-readable address. "
            "Provide decimal degree coordinates (e.g., lat=40.7128, lon=-74.0060 for NYC). "
            "Useful for interpreting coordinates from GPS devices, maps, or other sources. "
            "Coordinates can come from the geocode tool or be provided directly."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=True,
        ),
        structured_output=True,
    )

    # Add the elevation tool
    mcp.add_tool(
        location_server.get_elevation,
        "get_elevation",
        title="Get elevation data for coordinates",
        description=(
            "Get elevation data for latitude/longitude coordinates. "
            "Returns elevation in both meters and feet above sea level. "
            "Provide decimal degree coordinates (e.g., lat=35.6894, lon=-78.7767). "
            "If you have an address or place name, use the geocode tool first to get coordinates. "
            "Optionally specify dataset: srtm90m (90m resolution, global), srtm30m (30m, global), "
            "aster30m (30m, global), ned10m (10m, US only), or others. Default is srtm90m."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=True,
        ),
        structured_output=True,
    )

    return mcp


# Global app instance for the entry point
app: FastMCP | None = None


async def get_app() -> FastMCP:
    """Get or create the global app instance."""
    global app
    if app is None:
        app = await create_server()
    return app


async def main() -> None:
    """Main entry point for running the server."""
    logger = logging.getLogger(__name__)

    try:
        server = await create_server()

        # Check if running in STDIO mode (for MCP clients like Cursor)
        # or HTTP mode (for testing/debugging)
        if len(sys.argv) > 1 and sys.argv[1] == "--http":
            logger.info("Starting server in HTTP mode")
            await server.run_streamable_http_async()
        else:
            logger.info("Starting server in STDIO mode for MCP client")
            await server.run_stdio_async()
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
    except Exception:
        logger.exception("Server error")
        raise
    finally:
        # Clean up the services
        await close_geocoding_service()
        await close_elevation_service()


if __name__ == "__main__":
    asyncio.run(main())
