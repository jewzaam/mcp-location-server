"""
Tests for the geocoding functionality.
Generated By: Cursor (Claude Sonnet 4)
"""

from unittest.mock import MagicMock, patch

import httpx
import pytest

from mcp_location_server.geocoding import NominatimGeocodingService
from mcp_location_server.models import GeocodeRequest, GeocodeResponse, GeocodeResult

# Test constants
TEST_DC_LATITUDE = 38.8976633
TEST_DC_LONGITUDE = -77.0365739
TEST_IMPORTANCE = 0.9
TEST_LIMIT = 5


class TestNominatimGeocodingService:
    """Test cases for the Nominatim geocoding service."""

    @pytest.mark.asyncio
    async def test_geocode_success(self):
        """Test successful geocoding response."""
        # Mock response data
        mock_response_data = [
            {
                "display_name": "White House, 1600, Pennsylvania Avenue Northwest, Washington, DC 20500, United States",
                "lat": "38.8976633",
                "lon": "-77.0365739",
                "importance": 0.9,
                "type": "house",
                "class": "place",
                "osm_id": 123456,
                "osm_type": "way",
            },
        ]

        with patch.object(httpx.AsyncClient, "get") as mock_get:
            # Setup mock response
            mock_response = MagicMock()
            mock_response.raise_for_status = MagicMock()
            mock_response.json = MagicMock(return_value=mock_response_data)
            mock_get.return_value = mock_response

            # Create service and test
            service = NominatimGeocodingService()
            request = GeocodeRequest(query="White House", limit=1)

            result = await service.geocode(request)

            # Assertions
            assert isinstance(result, GeocodeResponse)
            assert result.count == 1
            assert result.query == "White House"
            assert len(result.results) == 1

            location = result.results[0]
            assert location.latitude == TEST_DC_LATITUDE
            assert location.longitude == TEST_DC_LONGITUDE
            assert location.importance == TEST_IMPORTANCE
            assert location.place_type == "house"
            assert location.place_class == "place"

    @pytest.mark.asyncio
    async def test_geocode_empty_results(self):
        """Test geocoding with no results found."""
        with patch.object(httpx.AsyncClient, "get") as mock_get:
            # Setup mock response with empty results
            mock_response = MagicMock()
            mock_response.raise_for_status = MagicMock()
            mock_response.json = MagicMock(return_value=[])
            mock_get.return_value = mock_response

            service = NominatimGeocodingService()
            request = GeocodeRequest(query="nonexistent location", limit=1)

            result = await service.geocode(request)

            # Assertions
            assert isinstance(result, GeocodeResponse)
            assert result.count == 0
            assert result.query == "nonexistent location"
            assert len(result.results) == 0

    @pytest.mark.asyncio
    async def test_geocode_http_error(self):
        """Test geocoding with HTTP error."""
        with patch.object(httpx.AsyncClient, "get") as mock_get:
            # Setup mock to raise HTTP error
            mock_get.side_effect = httpx.HTTPError("API request failed")

            service = NominatimGeocodingService()
            request = GeocodeRequest(query="test location", limit=1)

            # Should raise HTTPError
            with pytest.raises(httpx.HTTPError):
                await service.geocode(request)

    @pytest.mark.asyncio
    async def test_reverse_geocode_success(self):
        """Test successful reverse geocoding."""
        mock_response_data = {
            "display_name": "1600 Pennsylvania Avenue NW, Washington, DC 20500, United States",
            "lat": "38.8976633",
            "lon": "-77.0365739",
            "importance": 0.9,
            "type": "house",
            "class": "place",
            "osm_id": 123456,
            "osm_type": "way",
        }

        with patch.object(httpx.AsyncClient, "get") as mock_get:
            mock_response = MagicMock()
            mock_response.raise_for_status = MagicMock()
            mock_response.json = MagicMock(return_value=mock_response_data)
            mock_get.return_value = mock_response

            service = NominatimGeocodingService()

            result = await service.reverse_geocode(38.8976633, -77.0365739)

            # Assertions
            assert result is not None
            assert isinstance(result, GeocodeResult)
            assert result.latitude == TEST_DC_LATITUDE
            assert result.longitude == TEST_DC_LONGITUDE
            assert result.place_type == "house"

    @pytest.mark.asyncio
    async def test_reverse_geocode_no_result(self):
        """Test reverse geocoding with no result."""
        with patch.object(httpx.AsyncClient, "get") as mock_get:
            mock_response = MagicMock()
            mock_response.raise_for_status = MagicMock()
            mock_response.json = MagicMock(return_value={"error": "Unable to geocode"})
            mock_get.return_value = mock_response

            service = NominatimGeocodingService()

            result = await service.reverse_geocode(0.0, 0.0)

            # Should return None for no results
            assert result is None

    @pytest.mark.asyncio
    async def test_rate_limiting(self):
        """Test that rate limiting is enforced."""
        service = NominatimGeocodingService()

        # The rate limiter should be initialized
        assert service.rate_limiter is not None
        assert service.rate_limiter.min_interval == 1.0

    @pytest.mark.asyncio
    async def test_context_manager(self):
        """Test async context manager functionality."""
        async with NominatimGeocodingService() as service:
            assert service is not None
            assert hasattr(service, "client")

        # After exiting context, client should be closed
        # Note: In real usage, the client would be closed

    @pytest.mark.asyncio
    async def test_reverse_geocode_invalid_coordinates(self):
        """Test reverse geocoding with invalid coordinates."""
        service = NominatimGeocodingService()

        # Test invalid latitude (too high)
        with pytest.raises(ValueError, match="Latitude must be between -90.0 and 90.0"):
            await service.reverse_geocode(91.0, 0.0)

        # Test invalid latitude (too low)
        with pytest.raises(ValueError, match="Latitude must be between -90.0 and 90.0"):
            await service.reverse_geocode(-91.0, 0.0)

        # Test invalid longitude (too high)
        with pytest.raises(ValueError, match="Longitude must be between -180.0 and 180.0"):
            await service.reverse_geocode(0.0, 181.0)

        # Test invalid longitude (too low)
        with pytest.raises(ValueError, match="Longitude must be between -180.0 and 180.0"):
            await service.reverse_geocode(0.0, -181.0)

        # Test non-numeric coordinates
        with pytest.raises(ValueError, match="Invalid coordinate values"):
            await service.reverse_geocode("invalid", 0.0)

        with pytest.raises(ValueError, match="Invalid coordinate values"):
            await service.reverse_geocode(0.0, "invalid")


class TestGeocodeRequest:
    """Test cases for GeocodeRequest model."""

    def test_valid_request(self):
        """Test creating a valid geocode request."""
        request = GeocodeRequest(query="New York", limit=5)
        assert request.query == "New York"
        assert request.limit == TEST_LIMIT

    def test_default_limit(self):
        """Test default limit value."""
        request = GeocodeRequest(query="Paris")
        assert request.limit == 1

    def test_invalid_limit_too_low(self):
        """Test validation for limit too low."""
        with pytest.raises(ValueError, match="limit"):
            GeocodeRequest(query="London", limit=0)

    def test_invalid_limit_too_high(self):
        """Test validation for limit too high."""
        with pytest.raises(ValueError, match="limit"):
            GeocodeRequest(query="London", limit=20)

    def test_empty_query(self):
        """Test validation for empty query."""
        with pytest.raises(ValueError, match="query"):
            GeocodeRequest(query="")

    def test_query_too_long(self):
        """Test validation for query too long."""
        long_query = "x" * 501  # Exceeds max length of 500
        with pytest.raises(ValueError, match="query"):
            GeocodeRequest(query=long_query)
