"""
Geocoding service using OpenStreetMap Nominatim API.
Generated By: Cursor (Claude Sonnet 4)
"""

import asyncio
import time
from typing import List, Optional
from urllib.parse import quote

import httpx
from pydantic import ValidationError

from .models import GeocodeRequest, GeocodeResponse, GeocodeResult


class RateLimiter:
    """Rate limiter that enforces 1 request per second for Nominatim usage policy."""
    
    def __init__(self, requests_per_second: float = 1.0) -> None:
        self.min_interval = 1.0 / requests_per_second
        self.last_request_time = 0.0
    
    async def wait_if_needed(self) -> None:
        """Wait if necessary to respect rate limits."""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.min_interval:
            wait_time = self.min_interval - time_since_last
            await asyncio.sleep(wait_time)
        
        self.last_request_time = time.time()


class NominatimGeocodingService:
    """Service for geocoding addresses using OpenStreetMap Nominatim API."""
    
    def __init__(
        self, 
        base_url: str = "https://nominatim.openstreetmap.org",
        user_agent: str = "mcp-location-server/0.1.0",
        timeout: float = 10.0
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.user_agent = user_agent
        self.timeout = timeout
        self.rate_limiter = RateLimiter(requests_per_second=1.0)
        
        # Create HTTP client with proper headers
        self.client = httpx.AsyncClient(
            headers={
                "User-Agent": self.user_agent,
                "Accept": "application/json",
                "Accept-Language": "en-US,en;q=0.9",
            },
            timeout=self.timeout,
        )
    
    async def __aenter__(self) -> "NominatimGeocodingService":
        """Async context manager entry."""
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Async context manager exit."""
        await self.client.aclose()
    
    async def geocode(self, request: GeocodeRequest) -> GeocodeResponse:
        """
        Geocode an address or location name to coordinates.
        
        Args:
            request: GeocodeRequest containing query and limit
            
        Returns:
            GeocodeResponse with results
            
        Raises:
            httpx.HTTPError: If the API request fails
            ValidationError: If the response cannot be parsed
        """
        # Respect rate limits
        await self.rate_limiter.wait_if_needed()
        
        # Build the API URL
        url = f"{self.base_url}/search"
        
        params = {
            "q": request.query,  # httpx will handle URL encoding in params
            "format": "json",
            "addressdetails": "1",
            "limit": str(request.limit),
            "dedupe": "1",  # Remove duplicate results
            "extratags": "1",  # Include extra tags
        }
        
        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()
            
            # Parse the JSON response
            data = response.json()
            
            # Convert to our model format
            results = []
            for item in data:
                try:
                    result = GeocodeResult(
                        display_name=item.get("display_name", ""),
                        latitude=float(item.get("lat", 0.0)),
                        longitude=float(item.get("lon", 0.0)),
                        importance=item.get("importance"),
                        place_type=item.get("type"),
                        place_class=item.get("class"),
                        osm_id=item.get("osm_id"),
                        osm_type=item.get("osm_type"),
                    )
                    results.append(result)
                except (ValueError, TypeError) as e:
                    # Skip malformed results
                    continue
            
            return GeocodeResponse(
                results=results,
                query=request.query,
                count=len(results)
            )
            
        except httpx.HTTPError as e:
            # Re-raise with more context
            raise httpx.HTTPError(
                f"Failed to geocode '{request.query}': {str(e)}"
            ) from e
        except (ValueError, KeyError) as e:
            # Handle JSON parsing errors
            raise ValidationError(
                f"Invalid response format from Nominatim API: {str(e)}", 
                model=GeocodeResponse
            ) from e
    
    async def reverse_geocode(
        self, 
        latitude: float, 
        longitude: float
    ) -> Optional[GeocodeResult]:
        """
        Reverse geocode coordinates to an address.
        
        Args:
            latitude: Latitude in decimal degrees (-90 to 90)
            longitude: Longitude in decimal degrees (-180 to 180)
            
        Returns:
            GeocodeResult if found, None otherwise
            
        Raises:
            ValueError: If coordinates are invalid
            httpx.HTTPError: If the API request fails
        """
        # Validate coordinates
        try:
            lat = float(latitude)
            lon = float(longitude)
        except (TypeError, ValueError) as e:
            raise ValueError(f"Invalid coordinate values: lat={latitude}, lon={longitude}") from e
        
        if not (-90.0 <= lat <= 90.0):
            raise ValueError(f"Latitude must be between -90 and 90, got {lat}")
        
        if not (-180.0 <= lon <= 180.0):
            raise ValueError(f"Longitude must be between -180 and 180, got {lon}")
        
        # Respect rate limits
        await self.rate_limiter.wait_if_needed()
        
        url = f"{self.base_url}/reverse"
        params = {
            "lat": str(lat),
            "lon": str(lon),
            "format": "json",
            "addressdetails": "1",
            "extratags": "1",
        }
        
        try:
            response = await self.client.get(url, params=params)
            response.raise_for_status()
            
            data = response.json()
            
            # Check if we got a valid result
            if not data or "error" in data:
                return None
            
            return GeocodeResult(
                display_name=data.get("display_name", ""),
                latitude=float(data.get("lat", latitude)),
                longitude=float(data.get("lon", longitude)),
                importance=data.get("importance"),
                place_type=data.get("type"),
                place_class=data.get("class"),
                osm_id=data.get("osm_id"),
                osm_type=data.get("osm_type"),
            )
            
        except httpx.HTTPError as e:
            raise httpx.HTTPError(
                f"Failed to reverse geocode ({latitude}, {longitude}): {str(e)}"
            ) from e
        except (ValueError, KeyError, TypeError):
            # Return None for parsing errors in reverse geocoding
            return None


# Global service instance
_geocoding_service: Optional[NominatimGeocodingService] = None


async def get_geocoding_service() -> NominatimGeocodingService:
    """Get or create the global geocoding service instance."""
    global _geocoding_service
    
    if _geocoding_service is None:
        _geocoding_service = NominatimGeocodingService()
    
    return _geocoding_service


async def close_geocoding_service() -> None:
    """Close the global geocoding service instance."""
    global _geocoding_service
    
    if _geocoding_service is not None:
        await _geocoding_service.client.aclose()
        _geocoding_service = None 